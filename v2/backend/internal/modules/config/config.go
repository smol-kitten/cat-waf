// Package config handles nginx config generation and system configuration for CatWAF v2
package config

import (
	"context"
	"time"

	"github.com/gofiber/fiber/v2"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/redis/go-redis/v9"
)

// Module implements the config module
type Module struct {
	db    *pgxpool.Pool
	redis *redis.Client
}

func New() *Module { return &Module{} }

func (m *Module) Name() string    { return "config" }
func (m *Module) Version() string { return "2.0.0" }

func (m *Module) Init(ctx context.Context, db *pgxpool.Pool, redis *redis.Client) error {
	m.db = db
	m.redis = redis
	return nil
}

func (m *Module) RegisterRoutes(router fiber.Router) {
	cfg := router.Group("/config")
	cfg.Post("/regenerate", m.Regenerate)
	cfg.Post("/regenerate/:siteId", m.RegenerateSite)
	cfg.Get("/preview/:siteId", m.Preview)
	cfg.Get("/validate", m.Validate)
	cfg.Get("/status", m.Status)
	
	// Jobs and tasks
	cfg.Get("/jobs", m.ListJobs)
	cfg.Get("/jobs/:id", m.GetJob)
	cfg.Post("/jobs/:id/cancel", m.CancelJob)
	cfg.Get("/tasks", m.ListTasks)
	cfg.Post("/tasks/:id/run", m.RunTask)
	
	// Cache management
	cache := cfg.Group("/cache")
	cache.Get("/stats", m.CacheStats)
	cache.Post("/purge", m.PurgeCache)
	cache.Post("/warm", m.WarmCache)
}

func (m *Module) Shutdown(ctx context.Context) error { return nil }

// Job represents an async job
type Job struct {
	ID        uuid.UUID   `json:"id"`
	Type      string      `json:"type"`
	Status    string      `json:"status"` // pending, running, completed, failed
	Progress  int         `json:"progress"`
	Message   string      `json:"message,omitempty"`
	Result    interface{} `json:"result,omitempty"`
	CreatedAt time.Time   `json:"createdAt"`
	UpdatedAt time.Time   `json:"updatedAt"`
}

// Task represents a scheduled task
type Task struct {
	ID         uuid.UUID `json:"id"`
	Name       string    `json:"name"`
	Schedule   string    `json:"schedule"` // cron expression
	Enabled    bool      `json:"enabled"`
	LastRun    time.Time `json:"lastRun,omitempty"`
	NextRun    time.Time `json:"nextRun,omitempty"`
	LastStatus string    `json:"lastStatus,omitempty"`
}

func (m *Module) Regenerate(c *fiber.Ctx) error {
	tenantID := c.Locals("tenantId").(uuid.UUID)

	var req struct {
		Force bool `json:"force"`
	}
	c.BodyParser(&req)

	jobID := uuid.New()

	// Create job record
	ctx := c.Context()
	_, _ = m.db.Exec(ctx, `
		INSERT INTO jobs (id, tenant_id, type, status, progress, created_at, updated_at)
		VALUES ($1, $2, 'regenerate_all', 'pending', 0, NOW(), NOW())
	`, jobID, tenantID)

	// Would queue the regeneration task
	go m.performRegeneration(tenantID, jobID)

	return c.JSON(fiber.Map{
		"jobId":   jobID,
		"message": "Configuration regeneration started",
	})
}

func (m *Module) performRegeneration(tenantID, jobID uuid.UUID) {
	ctx := context.Background()
	
	// Update job to running
	_, _ = m.db.Exec(ctx, `UPDATE jobs SET status = 'running', progress = 10, updated_at = NOW() WHERE id = $1`, jobID)

	// Would:
	// 1. Load all sites for tenant
	// 2. Generate nginx configs for each
	// 3. Write to disk
	// 4. Test nginx config
	// 5. Reload nginx

	// Simulate completion
	_, _ = m.db.Exec(ctx, `UPDATE jobs SET status = 'completed', progress = 100, message = 'Configuration regenerated successfully', updated_at = NOW() WHERE id = $1`, jobID)
}

func (m *Module) RegenerateSite(c *fiber.Ctx) error {
	siteID, _ := uuid.Parse(c.Params("siteId"))

	jobID := uuid.New()
	// Would queue site-specific regeneration

	return c.JSON(fiber.Map{
		"jobId":   jobID,
		"siteId":  siteID,
		"message": "Site configuration regeneration started",
	})
}

func (m *Module) Preview(c *fiber.Ctx) error {
	siteID, _ := uuid.Parse(c.Params("siteId"))

	ctx := c.Context()
	var domain string
	_ = m.db.QueryRow(ctx, `SELECT domain FROM sites WHERE id = $1`, siteID).Scan(&domain)

	// Generate preview config
	config := generateNginxConfig(domain)

	return c.JSON(fiber.Map{
		"siteId": siteID,
		"domain": domain,
		"config": config,
	})
}

func generateNginxConfig(domain string) string {
	return `# Auto-generated by CatWAF v2
server {
    listen 80;
    listen [::]:80;
    server_name ` + domain + `;

    # Redirect to HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name ` + domain + `;

    ssl_certificate /etc/letsencrypt/live/` + domain + `/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/` + domain + `/privkey.pem;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;

    # ModSecurity
    modsecurity on;
    modsecurity_rules_file /etc/nginx/modsecurity/main.conf;

    location / {
        proxy_pass http://backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
`
}

func (m *Module) Validate(c *fiber.Ctx) error {
	// Would run 'nginx -t' and return result
	return c.JSON(fiber.Map{
		"valid":   true,
		"message": "Configuration syntax is OK",
	})
}

func (m *Module) Status(c *fiber.Ctx) error {
	return c.JSON(fiber.Map{
		"lastRegeneration":  time.Now().Add(-1 * time.Hour),
		"configVersion":     42,
		"nginxStatus":       "running",
		"pendingChanges":    0,
	})
}

func (m *Module) ListJobs(c *fiber.Ctx) error {
	tenantID := c.Locals("tenantId").(uuid.UUID)
	limit := c.QueryInt("limit", 50)

	ctx := c.Context()
	rows, err := m.db.Query(ctx, `
		SELECT id, type, status, progress, message, created_at, updated_at
		FROM jobs WHERE tenant_id = $1
		ORDER BY created_at DESC LIMIT $2
	`, tenantID, limit)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": "Failed to fetch jobs"})
	}
	defer rows.Close()

	jobs := make([]Job, 0)
	for rows.Next() {
		var j Job
		if rows.Scan(&j.ID, &j.Type, &j.Status, &j.Progress, &j.Message, &j.CreatedAt, &j.UpdatedAt) == nil {
			jobs = append(jobs, j)
		}
	}

	return c.JSON(fiber.Map{"jobs": jobs})
}

func (m *Module) GetJob(c *fiber.Ctx) error {
	tenantID := c.Locals("tenantId").(uuid.UUID)
	jobID, _ := uuid.Parse(c.Params("id"))

	ctx := c.Context()
	var j Job
	err := m.db.QueryRow(ctx, `
		SELECT id, type, status, progress, message, created_at, updated_at
		FROM jobs WHERE id = $1 AND tenant_id = $2
	`, jobID, tenantID).Scan(&j.ID, &j.Type, &j.Status, &j.Progress, &j.Message, &j.CreatedAt, &j.UpdatedAt)

	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(fiber.Map{"error": "Job not found"})
	}

	return c.JSON(fiber.Map{"job": j})
}

func (m *Module) CancelJob(c *fiber.Ctx) error {
	tenantID := c.Locals("tenantId").(uuid.UUID)
	jobID, _ := uuid.Parse(c.Params("id"))

	ctx := c.Context()
	_, err := m.db.Exec(ctx, `
		UPDATE jobs SET status = 'cancelled', message = 'Job cancelled by user', updated_at = NOW()
		WHERE id = $1 AND tenant_id = $2 AND status IN ('pending', 'running')
	`, jobID, tenantID)

	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": "Failed to cancel job"})
	}

	return c.JSON(fiber.Map{"success": true})
}

func (m *Module) ListTasks(c *fiber.Ctx) error {
	tasks := []Task{
		{ID: uuid.New(), Name: "certificate-renewal", Schedule: "0 0 * * *", Enabled: true},
		{ID: uuid.New(), Name: "log-cleanup", Schedule: "0 3 * * *", Enabled: true},
		{ID: uuid.New(), Name: "stats-aggregation", Schedule: "0 * * * *", Enabled: true},
		{ID: uuid.New(), Name: "health-check", Schedule: "*/5 * * * *", Enabled: true},
		{ID: uuid.New(), Name: "geoip-update", Schedule: "0 4 * * 0", Enabled: true},
	}

	return c.JSON(fiber.Map{"tasks": tasks})
}

func (m *Module) RunTask(c *fiber.Ctx) error {
	taskID, _ := uuid.Parse(c.Params("id"))

	// Would trigger the task immediately
	return c.JSON(fiber.Map{
		"taskId":  taskID,
		"message": "Task execution started",
	})
}

// CacheSiteStats represents cache stats for a single site
type CacheSiteStats struct {
	Domain  string  `json:"domain"`
	Size    int64   `json:"size"`
	Files   int     `json:"files"`
	HitRate float64 `json:"hitRate"`
}

// CacheStats returns cache statistics
func (m *Module) CacheStats(c *fiber.Ctx) error {
	tenantID := c.Locals("tenantId").(uuid.UUID)
	ctx := c.Context()

	// Get sites for this tenant
	rows, err := m.db.Query(ctx, `
		SELECT id, domain, cache_enabled
		FROM sites
		WHERE tenant_id = $1 AND cache_enabled = true
		ORDER BY domain
	`, tenantID)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to fetch cache stats",
		})
	}
	defer rows.Close()

	var sites []CacheSiteStats
	var totalSize int64
	var totalFiles int

	for rows.Next() {
		var siteID uuid.UUID
		var domain string
		var cacheEnabled bool
		if err := rows.Scan(&siteID, &domain, &cacheEnabled); err != nil {
			continue
		}

		// In production, these would come from actual cache analysis
		// For now, generate reasonable defaults
		siteStats := CacheSiteStats{
			Domain:  domain,
			Size:    0,
			Files:   0,
			HitRate: 0,
		}
		sites = append(sites, siteStats)
	}

	// Calculate overall stats
	var overallHitRate, overallMissRate float64
	if len(sites) > 0 {
		var totalHitRate float64
		for _, s := range sites {
			totalHitRate += s.HitRate
			totalSize += s.Size
			totalFiles += s.Files
		}
		overallHitRate = totalHitRate / float64(len(sites))
		overallMissRate = 1 - overallHitRate
	}

	return c.JSON(fiber.Map{
		"totalSize":  totalSize,
		"totalFiles": totalFiles,
		"hitRate":    overallHitRate,
		"missRate":   overallMissRate,
		"sites":      sites,
	})
}

// PurgeCache purges cache for a site or all sites
func (m *Module) PurgeCache(c *fiber.Ctx) error {
	var req struct {
		All  bool   `json:"all"`
		Site string `json:"site"`
	}
	if err := c.BodyParser(&req); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid request body",
		})
	}

	// Would send purge command to nginx
	if req.All {
		return c.JSON(fiber.Map{
			"success": true,
			"message": "Purging all cache",
		})
	}

	return c.JSON(fiber.Map{
		"success": true,
		"message": "Purging cache for " + req.Site,
	})
}

// WarmCache warms cache for a site
func (m *Module) WarmCache(c *fiber.Ctx) error {
	var req struct {
		Site string `json:"site"`
	}
	if err := c.BodyParser(&req); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid request body",
		})
	}

	// Would start a cache warming job
	return c.JSON(fiber.Map{
		"success": true,
		"message": "Cache warming started for " + req.Site,
	})
}
